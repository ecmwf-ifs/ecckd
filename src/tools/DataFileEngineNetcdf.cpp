/// @file      DataFileEngineNetcdf.cpp
/// @brief     Implements the DataFileEngineNetcdf class
/// @author    Robin J. Hogan
/// @author    Alessio Bozzo
/// @copyright 2006-2015 University of Reading
/// @copyright (C) Copyright 2015- ECMWF
/// @license   This software is licensed under the terms of the Apache Licence Version 2.0
///            which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
///            In applying this licence, ECMWF does not waive the privileges and immunities
///            granted to it by virtue of its status as an intergovernmental organisation
///            nor does it submit to any jurisdiction.

#include "DataFileEngineNetcdf.h"

#include <string.h>
#include <cstdio>
#include <netcdf.h>

static int ncstatus;
// here the netcdf errors throw a generic unexpected exception code
// but the full error and code generated by the NetCDF function
// is reported in the message
#define NC_CHECK_UNNAMED(a) if ((ncstatus = (a)) != NC_NOERR) {	\
    ERROR << nc_strerror(ncstatus) << " [NC code " << ncstatus << "]\n"; \
    THROW(PRODUCT_FORMAT_ERROR); }
#define NC_CHECK(a, name) if ((ncstatus = (a)) != NC_NOERR) {	\
    ERROR << nc_strerror(ncstatus) << " [NC code " << ncstatus << "]" \
	  << ": " << name << "\n"; THROW(PRODUCT_FORMAT_ERROR); }
#define NC_CHECK_NOTHROW(a, name) if ((ncstatus = (a)) != NC_NOERR) {	\
    ERROR << nc_strerror(ncstatus) << " [NC code " << ncstatus << "]" \
	  << ": " << name << "\n"; }

#define CONDITIONAL_ERROR(message) \
  if (throw_exceptions_) {	   \
    ERROR << message;		   \
    THROW(UNEXPECTED_EXCEPTION);   \
  }				   \
  else {			   \
    WARNING << message;		   \
    ENDWARNING;			   \
    return false;		   \
  }

// Open the file with an absolute path
DataFileEngineNetcdf::
DataFileEngineNetcdf(const std::string& filename, bool throw_exceptions)
  : throw_exceptions_(throw_exceptions)
{
  int  numgrps;
  NC_CHECK(nc_open(filename.c_str(), 0, &root_ncid_), filename);
  DETAIL << "Opened " << filename << "\n";
  filename_ = filename;

#ifdef NC_NETCDF4
  // Get a list of ncids for the root group (that is, find out if
  // there are any groups already defined)
  NC_CHECK(nc_inq_grps(root_ncid_, &numgrps, NULL),filename);
  if (numgrps != 0) {
    // We have groups: look for one called "ScienceData"
    size_t len;
    intVector ncids(numgrps);
    NC_CHECK(nc_inq_grps(root_ncid_, NULL, ncids.data_pointer()),filename);
    // Loop over the group ids and store the group names
    char name_in[15];
    for (int i = 1; i < numgrps; i++){
      NC_CHECK(nc_inq_grpname_full(ncids(i), &len, name_in),filename);
      if (strcmp ("/ScienceData",name_in) == 0) {
	// Found: set the ncid that will be used by subsequent calls
	// to find variables
	ncid_ = ncids(i);
	break;
      }
      else {
	ERROR << "Error reading " << filename 
	      << " no \"ScienceData\" group";
	THROW(PRODUCT_FORMAT_ERROR);
      }
    }
  }
  else {
    // No groups found
    ncid_ = root_ncid_;
  }
#else
  // NetCDF3: don't look for groups
  ncid_ = root_ncid_;
#endif


}

// Close the file
DataFileEngineNetcdf::
~DataFileEngineNetcdf()
{
  // Shouldn't throw an exception in a destructor
  NC_CHECK_NOTHROW(nc_close(root_ncid_), filename_);
  ncid_ = 0;
  DETAIL << "Closed " << filename_ << "\n";
}

// Get the size of a variable
IntVector 
DataFileEngineNetcdf::size(const std::string& varname) const
{
  IntVector out;
  int varid;
  if (nc_inq_varid(ncid_, varname.c_str(), &varid) != NC_NOERR) {
    // Variable not found
    return out;
  }
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims == 0) {
    // Scalar
    out.resize(1);
    out = 1;
    return out;
  }
  
  // First fill "out" with the dimention IDs
  out.resize(ndims);
  NC_CHECK(nc_inq_vardimid(ncid_, varid, out.data_pointer()), varname);
  for (int idim = 0; idim < ndims; idim++) {
    // Replace the dimension ID with its length
    size_t len;
    NC_CHECK(nc_inq_dimlen(ncid_, out(idim), &len), varname);
    out(idim) = len;
  }
  return out;
}

IntVector 
DataFileEngineNetcdf::size(const std::string& scope, const std::string& varname) const
{
  IntVector out;
  int varid;
  if (nc_inq_varid(ncid_, scope.c_str(), &varid) != NC_NOERR) {
    // Variable not found
    return out;
  };
  // Find the length of attribute "varname" in variable "scope"
  size_t len;
  NC_CHECK(nc_inq_attlen(ncid_, varid, varname.c_str(), &len), varname);
  out.resize(1);
  out = len;
  return out;    
}


// Read single real numbers
bool
DataFileEngineNetcdf::
read(Real& x, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 2) {
    CONDITIONAL_ERROR("Cannot read single element from netcdf file with more than 2 dimensions: "
		      + varname);
  }
  if (j == -1) j = 0;
  if (i == -1) i = 0;
  size_t index[2] = {static_cast<size_t>(j), static_cast<size_t>(i) };
#ifdef REAL_IS_FLOAT
  NC_CHECK(nc_get_var1_float(ncid_, varid, index, &x), varname);
#else
  NC_CHECK(nc_get_var1_double(ncid_, varid, index, &x), varname);
#endif
  return true;
}

bool
DataFileEngineNetcdf::
read(Real& x, const std::string& scope, 
     const std::string& varname, int j, int i) const
{
  if (j >= 0 || i >= 0) {
    CONDITIONAL_ERROR("Attempt to read specific real element of a netcdf attribute: "
		      + scope + "." + varname);
    return false;
  }
  int varid;
  if (scope == DATA_FILE_GLOBAL_SCOPE) {
    varid = NC_GLOBAL;
  }
  else {
    NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  }
  size_t n;
  NC_CHECK(nc_inq_attlen(ncid_, varid, varname.c_str(), &n), varname);
  if (n > 1) {
    CONDITIONAL_ERROR("Attempt to read one real element from multi-element netcdf attribute: "
		      + scope + "." + varname);
  }
#ifdef REAL_IS_FLOAT
  NC_CHECK(nc_get_att_float(ncid_, varid, varname.c_str(), &x), varname);
#else
  NC_CHECK(nc_get_att_double(ncid_, varid, varname.c_str(), &x), varname);
#endif
  return true;
}

// Read single integers
bool
DataFileEngineNetcdf::
read(int& x, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 2) {
    CONDITIONAL_ERROR("Cannot read single element from netcdf file with more than 2 dimensions: "
		      + varname);
  }
  if (j == -1) j = 0;
  if (i == -1) i = 0;
  size_t index[2] = {static_cast<size_t>(j), static_cast<size_t>(i) };
  NC_CHECK(nc_get_var1_int(ncid_, varid, index, &x), varname);
  return true;
}

bool
DataFileEngineNetcdf::
read(int& x, const std::string& scope, 
     const std::string& varname, int j, int i) const
{
  if (j >= 0 || i >= 0) {
    CONDITIONAL_ERROR("Attempt to read specific integer of a netcdf attribute: "
		      + scope + "." + varname);
    return false;
  }
  int varid;
  if (scope == DATA_FILE_GLOBAL_SCOPE) {
    varid = NC_GLOBAL;
  }
  else {
    NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  }
  size_t n;
  NC_CHECK(nc_inq_attlen(ncid_, varid, varname.c_str(), &n), varname);
  if (n > 1) {
    CONDITIONAL_ERROR("Attempt to read one integer from multi-element netcdf attribute: "
		      + scope + "." + varname);
  }
  NC_CHECK(nc_get_att_int(ncid_, varid, varname.c_str(), &x), varname);
  return true;
}


// Read single booleans
bool
DataFileEngineNetcdf::
read(bool& x, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 2) {
    CONDITIONAL_ERROR("Cannot read single element from netcdf file with more than 2 dimensions: "
		      + varname);
  }
  if (j == -1) j = 0;
  if (i == -1) i = 0;
  size_t index[2] = {static_cast<size_t>(j), static_cast<size_t>(i) };
  int x_ = 0;
  NC_CHECK(nc_get_var1_int(ncid_, varid, index, &x_), varname);
  x = (x_ != 0);
  return true;
}

bool
DataFileEngineNetcdf::
read(bool& x, const std::string& scope, 
     const std::string& varname, int j, int i) const
{
  if (j >= 0 || i >= 0) {
    CONDITIONAL_ERROR("Attempt to read specific integer of a netcdf attribute: "
		      + scope + "." + varname);
    return false;
  }
  int varid;
  if (scope == DATA_FILE_GLOBAL_SCOPE) {
    varid = NC_GLOBAL;
  }
  else {
    NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  }
  size_t n;
  NC_CHECK(nc_inq_attlen(ncid_, varid, varname.c_str(), &n), varname);
  if (n > 1) {
    CONDITIONAL_ERROR("Attempt to read one integer from multi-element netcdf attribute: "
		      + scope + "." + varname);
  }
  int x_ = 0;
  NC_CHECK(nc_get_att_int(ncid_, varid, varname.c_str(), &x_), varname);
  x = (x_ != 0);
  return true;
}



// Read strings
bool
DataFileEngineNetcdf::
read(std::string& s, const std::string& varname, int j) const
{
  if (j >= 0) {
    CONDITIONAL_ERROR("Attempt to read substring of netcdf variable: "
		      + varname);
  }
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 1) {
    CONDITIONAL_ERROR("Cannot read from netcdf string with more than 1 dimension: "
		      + varname);
  }
  int dimid;
  NC_CHECK(nc_inq_vardimid(ncid_, varid, &dimid), varname);
  size_t len;
  NC_CHECK_UNNAMED(nc_inq_dimlen(ncid_, dimid, &len));
  char* text = new char[len+1];
  NC_CHECK(nc_get_var_text(ncid_, varid, text), varname);
  text[len] = 0;
  s = text;
  delete[] text;
  return true;
}

bool
DataFileEngineNetcdf::
read(std::string& s, const std::string& scope,
     const std::string& varname, int j) const
{
  if (j >= 0) {
    CONDITIONAL_ERROR("Attempt to read substring of netcdf attribute: "
		      + scope + "." + varname);
  }
  int varid;
  if (scope == DATA_FILE_GLOBAL_SCOPE) {
    varid = NC_GLOBAL;
  }
  else {
    NC_CHECK(nc_inq_varid(ncid_, scope.c_str(), &varid), scope);
  }
  size_t len;
  if (nc_inq_attlen(ncid_, varid, varname.c_str(), &len) != NC_NOERR) {
    return false;
  }
  char* text = new char[len+1];
  NC_CHECK(nc_get_att_text(ncid_, varid, varname.c_str(), text), varname);
  text[len] = 0;
  s = text;
  delete[] text;
  return true;
}

// Read slice vector of real numbers
bool
DataFileEngineNetcdf::
read_slice(Vector& v, const std::string& varname, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 2) {
    CONDITIONAL_ERROR("Cannot extract slice from netcdf variable with more than 2 dimensions: "
		      + varname);
  }
  
  int dimid[2];
  NC_CHECK(nc_inq_vardimid(ncid_, varid, dimid), varname);
  size_t len[2];
  for (int idim = 0; idim < ndims; idim++) {
    NC_CHECK_UNNAMED(nc_inq_dimlen(ncid_, dimid[idim], len+idim));
  }
  //LOG << " len(0) " << len[0] << " len(1) " << len[1] << "\n";
  size_t start[3] = {0, 0};
  start[1] = i;
  len[1] = 1;

  size_t length = 1;
  length = len[0];

  Real* data = new Real[length];
#ifdef REAL_IS_FLOAT
  NC_CHECK(nc_get_vara_float(ncid_, varid, start, len, data), varname);
#else
  NC_CHECK(nc_get_vara_double(ncid_, varid, start, len, data), varname);
#endif
  Vector v_tmp(data, expression_size(length));
  v.resize(length);
  v = v_tmp;
  delete[] data;
  return true;
}


// Read vector of real numbers
bool
DataFileEngineNetcdf::
read(Vector& v, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 3) {
    CONDITIONAL_ERROR("Cannot read from netcdf variable with more than 3 dimensions: "
		      + varname);
  }
  else if (i < 0 && ndims == 3) {
    CONDITIONAL_ERROR("No second index specified for vector extracted from 3-D netcdf array: "
		      + varname);
  }
  else if (j < 0 && ndims > 1) {
    CONDITIONAL_ERROR("No index specified for vector extracted from 2-D or 3-D netcdf array: "
		      + varname);
  }
  
  int dimid[3];
  NC_CHECK(nc_inq_vardimid(ncid_, varid, dimid), varname);
  size_t len[3];
  for (int idim = 0; idim < ndims; idim++) {
    NC_CHECK_UNNAMED(nc_inq_dimlen(ncid_, dimid[idim], len+idim));
  }
  size_t start[3] = {0, 0, 0};
  if (j >= 0) { 
    start[0] = j;
    len[0] = 1;
    if (i >= 0) {
      start[1] = i;
      len[1] = 1;
    }
  }
  size_t length = 1;
  if (ndims > 0) {
    length = len[ndims-1];
  }
  Real* data = new Real[length];
#ifdef REAL_IS_FLOAT
  NC_CHECK(nc_get_vara_float(ncid_, varid, start, len, data), varname);
#else
  NC_CHECK(nc_get_vara_double(ncid_, varid, start, len, data), varname);
#endif
  Vector v_tmp(data, expression_size(length));
  v.resize(length);
  v = v_tmp;
  delete[] data;
  return true;
}

bool
DataFileEngineNetcdf::
read(Vector& v, const std::string& scope,
     const std::string& varname) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, scope.c_str(), &varid), scope);
  size_t len;
  NC_CHECK(nc_inq_attlen(ncid_, varid, varname.c_str(), &len), varname);
  Real* data = new Real[len];
#ifdef REAL_IS_FLOAT
  NC_CHECK(nc_get_att_float(ncid_, varid, varname.c_str(), data), varname);
#else
  NC_CHECK(nc_get_att_double(ncid_, varid, varname.c_str(), data), varname);
#endif
  Vector v_tmp(data,expression_size(len));
  v.resize(len);
  v = v_tmp;
  delete[] data;
  return true;    
}

// Read vector of integers
bool
DataFileEngineNetcdf::
read(IntVector& v, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 3) {
    CONDITIONAL_ERROR("Cannot read from netcdf variable with more than 3 dimensions: "
		      + varname);
  }
  else if (i < 0 && ndims == 3) {
    CONDITIONAL_ERROR("No second index specified for vector extracted from 3-D netcdf array: "
		      + varname);
  }
  else if (j < 0 && ndims > 1) {
    CONDITIONAL_ERROR("No index specified for vector extracted from 2-D or 3-D netcdf array: "
		      + varname);
  }
  
  int dimid[3];
  NC_CHECK(nc_inq_vardimid(ncid_, varid, dimid), varname);
  size_t len[3];
  for (int idim = 0; idim < ndims; idim++) {
    NC_CHECK_UNNAMED(nc_inq_dimlen(ncid_, dimid[idim], len+idim));
  }
  size_t start[3] = {0, 0, 0};
  if (j >= 0) { 
    start[0] = j;
    len[0] = 1;
    if (i >= 0) {
      start[1] = i;
      len[1] = 1;
    }
  }
  size_t length = 1;
  if (ndims > 0) {
    length = len[ndims-1];
  }
  
  int* data = new int[length];
  NC_CHECK(nc_get_vara_int(ncid_, varid, start, len, data), varname);
  IntVector v_tmp(data, expression_size(length));
  v.resize(length);
  v = v_tmp;
  delete[] data;
  return true;
}

bool
DataFileEngineNetcdf::
read(IntVector& v, const std::string& scope,
     const std::string& varname) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, scope.c_str(), &varid), scope);
  size_t len;
  NC_CHECK(nc_inq_attlen(ncid_, varid, varname.c_str(), &len), varname);
  int* data = new int[len];
  NC_CHECK(nc_get_att_int(ncid_, varid, varname.c_str(), data), varname);
  IntVector v_tmp(data, expression_size(len));
  v.resize(len);
  v = v_tmp;
  delete[] data;
  return true;
}




bool
DataFileEngineNetcdf::
read(Matrix& M, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 4) {
    CONDITIONAL_ERROR("Cannot read from netcdf array with more than 4 dimensions: "
		      + varname);
  }
  else if (i < 0 && ndims == 4) {
    CONDITIONAL_ERROR("No second index specified for matrix extracted from 4-D netcdf array: "
		      + varname);
  }
  else if (j < 0 && ndims > 2) {
    CONDITIONAL_ERROR("No index specified for matrix extracted from 3-D or 4-D netcdf array: "
		      + varname);
  }
  
  int dimid[4];
  NC_CHECK(nc_inq_vardimid(ncid_, varid, dimid), varname);
  size_t len[4] = {0, 0, 0, 0};
  for (int idim = 0; idim < ndims; idim++) {
    NC_CHECK_UNNAMED(nc_inq_dimlen(ncid_, dimid[idim], len+idim));
  }
  //LOG << " len(0) " << len[0] << " len(1) " << len[1] << " len(2) " << len[2] << " len(3) " << len[3] << "\n";
  size_t start[4] = {0, 0, 0, 0};
  if (j >= 0) { 
    start[0] = j;
    len[0] = 1;
    if (i >= 0) {
      start[1] = i;
      len[1] = 1;
    }
  }
  
  if (ndims >= 2) {
    Real* data = new Real[len[ndims-1]*len[ndims-2]];
    //LOG << "length: " << len[ndims-1]*len[ndims-2] << "\n";
#ifdef REAL_IS_FLOAT
    NC_CHECK(nc_get_vara_float(ncid_, varid, start, len, data), varname);
#else
    NC_CHECK(nc_get_vara_double(ncid_, varid, start, len, data), varname);
#endif
    M.resize(len[ndims-2],len[ndims-1]);
    Real* data_ptr = data;
    for (size_t jj = 0; jj < len[ndims-2]; jj++) {
      for (size_t ii = 0; ii < len[ndims-1]; ii++) {
	M(jj, ii) = *data_ptr;
	data_ptr++;
      }
    }
    delete[] data;
  }
  else {
    Real* data = new Real[len[ndims-1]];
#ifdef REAL_IS_FLOAT
    NC_CHECK(nc_get_vara_float(ncid_, varid, start, len, data), varname);
#else
    NC_CHECK(nc_get_vara_double(ncid_, varid, start, len, data), varname);
#endif
    M.resize(len[ndims-1],1);
    Real* data_ptr = data;
    for (size_t ii = 0; ii < len[ndims-1]; ii++) {
      M(ii,0) = *data_ptr;
      data_ptr++;
    }
    delete[] data;
  }
  return true;
}

bool
DataFileEngineNetcdf::
read(Matrix& M, const std::string& scope,
     const std::string& varname) const
{
  CONDITIONAL_ERROR("Cannot extract a matrix from a NetCDF attribute: "
		    + scope + "." + varname);
  return false;
}



bool
DataFileEngineNetcdf::
read(Array3D& M, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 5) {
    CONDITIONAL_ERROR("Cannot read from netcdf array with more than 5 dimensions: "
		      + varname);
  }
  else if (i < 0 && ndims == 5) {
    CONDITIONAL_ERROR("No second index specified for 3-D array extracted from 5-D netcdf array: "
		      + varname);
  }
  else if (j < 0 && ndims > 3) {
    CONDITIONAL_ERROR("No index specified for 3-D array extracted from 4-D or 5-D netcdf array: "
		      + varname);
  }
  
  int* dimids = new int[ndims];
  size_t* start = new size_t[ndims];
  size_t* count = new size_t[ndims];
  NC_CHECK(nc_inq_vardimid(ncid_, varid, dimids), varname);
  std::vector<int> array_dim;
  int start_dim = 0;
  if (j >= 0) {
    start[0] = j;
    count[0] = 1;
    if (i >= 0) {
      start_dim = 2;
      start[1] = i;
      count[1] = 1;
    }
    else {
      start_dim = 1;
    }
  }
  
  for (int k = start_dim; k < ndims; k++) {
    size_t len;
    NC_CHECK(nc_inq_dimlen(ncid_, dimids[k], &len), varname);
    array_dim.push_back(len);
    start[k] = 0;
    count[k] = len;
  }
  delete[] dimids;
  
  M.resize(&array_dim[0], true); // force_contiguous=true
#ifdef REAL_IS_FLOAT
  NC_CHECK(nc_get_vara_float(ncid_, varid, start, 
			     count, M.data_pointer()), varname);
#else
  NC_CHECK(nc_get_vara_double(ncid_, varid, start, 
			      count, M.data_pointer()), varname);
#endif
  delete[] start;
  delete[] count;
  return true;
}

bool
DataFileEngineNetcdf::
read(Array4D& M, const std::string& varname, int j, int i) const
{
  int varid;
  NC_CHECK(nc_inq_varid(ncid_, varname.c_str(), &varid), varname);
  int ndims;
  NC_CHECK(nc_inq_varndims(ncid_, varid, &ndims), varname);
  if (ndims > 6) {
    CONDITIONAL_ERROR("Cannot read from netcdf array with more than 6 dimensions: "
		      + varname);
  }
  else if (i < 0 && ndims == 6) {
    CONDITIONAL_ERROR("No second index specified for 4-D array extracted from 6-D netcdf array: "
		      + varname);
  }
  else if (j < 0 && ndims > 4) {
    CONDITIONAL_ERROR("No index specified for 4-D array extracted from 5-D or 6-D netcdf array: "
		      + varname);
  }
  
  int* dimids = new int[ndims];
  size_t* start = new size_t[ndims];
  size_t* count = new size_t[ndims];
  NC_CHECK(nc_inq_vardimid(ncid_, varid, dimids), varname);
  std::vector<int> array_dim;
  int start_dim = 0;
  if (j >= 0) {
    start[0] = j;
    count[0] = 1;
    if (i >= 0) {
      start_dim = 2;
      start[1] = i;
      count[1] = 1;
    }
    else {
      start_dim = 1;
    }
  }
  
  for (int k = start_dim; k < ndims; k++) {
    size_t len;
    NC_CHECK(nc_inq_dimlen(ncid_, dimids[k], &len), varname);
    array_dim.push_back(len);
    start[k] = 0;
    count[k] = len;
  }
  delete[] dimids;
  
  M.resize(&array_dim[0], true); // force_contiguous=true
#ifdef REAL_IS_FLOAT
  NC_CHECK(nc_get_vara_float(ncid_, varid, start, 
			     count, M.data_pointer()), varname);
#else
  NC_CHECK(nc_get_vara_double(ncid_, varid, start, 
			      count, M.data_pointer()), varname);
#endif
  delete[] start;
  delete[] count;
  return true;
}


// Return the entire contents of the file as a string
bool
DataFileEngineNetcdf::
read(std::string& s) const
{
  CONDITIONAL_ERROR("Cannot read the entire contents of a NetCDF file into a string");
  return false;
}

// Get a list of variable or argument names present in the file. If
// "scope" is omitted then 
bool
DataFileEngineNetcdf::
get_names(std::list<std::string>& names, const std::string& scope) const
{
  ERROR << "DataFileEngineNetcdf::get_names not yet implemented for NetCDF files";
  THROW(UNEXPECTED_EXCEPTION);
}


// Copy all the attributes of varname to a variable in the specified
// output file; if the last argument is omitted it will be assumed
// that the target variable has the same name as the source variable
bool
DataFileEngineNetcdf::
copy_attributes(const std::string& varname,
		OutputDataFile* output, const std::string& output_varname) const
{
  ERROR << "DataFileEngineNetcdf::copy_attributes not yet implemented for NetCDF files";
  THROW(UNEXPECTED_EXCEPTION);
}


bool
DataFileEngineNetcdf::
exist(const std::string& varname) const
{
  int varid;
  if (nc_inq_varid(ncid_, varname.c_str(), &varid) == NC_NOERR) {
    return true;
  }
  else {
    return false;
  }
}

bool
DataFileEngineNetcdf::
exist(const std::string& scope, const std::string& varname) const
{
  int varid;
  if (nc_inq_varid(ncid_, scope.c_str(), &varid) == NC_NOERR) {
    int attid;
    if (nc_inq_attid(ncid_, varid, varname.c_str(), &attid) == NC_NOERR) {
      return true;
    }
  }
  return false;
}

// For NETCDF 4
/*
bool
DataFileEngineNetcdf::read_missing_value(Real& missing_val, const std::string& varname) const
{
  if (type_ == CONFIG) {
    rc_set_section(data_, varname.c_str());
    bool status = rc_assign_real(data_, "missing_value", &missing_val);
    rc_set_section(data_, 0);
    return status;
  }
  else if (type_ == NETCDF) {
    int varid;
    if (nc_inq_varid(ncid_, varname.c_str(), &varid) == NC_NOERR) {
      int is_no_missing_value;
      NC_CHECK(nc_inq_var_fill(ncid_, varid, &is_no_missing_value, &missing_value),
	       varname);
      if (is_no_missing_value) {
	size_t n;
	const char* missing_value = "missing_value";
	NC_CHECK(nc_inq_attlen(ncid_, varid, missing_value, &n), varname);
	if (n > 1) {
	  CONDITIONAL_ERROR("Attempt to read missing_value as one real element from multi-element netcdf attribute");
	}
#ifdef REAL_IS_FLOAT
	NC_CHECK(nc_get_att_float(ncid_, varid, missing_value, &missing_val), varname);
#else
	NC_CHECK(nc_get_att_double(ncid_, varid, missing_value, &missing_val), varname);
#endif
	return true;
      }
    }
  }
  return false;
}
*/

// For NETCDF 3 (and probably 4)
bool
DataFileEngineNetcdf::read_missing_value(Real& missing_val, const std::string& varname) const
{
  int varid;
  if (nc_inq_varid(ncid_, varname.c_str(), &varid) == NC_NOERR) {
    const char* missing_value = "missing_value";
    for (int i = 0; i < 2; i++) {
      size_t n = 0;
      if (nc_inq_attlen(ncid_, varid, missing_value, &n) == NC_NOERR) {
	if (n > 1) {
	  CONDITIONAL_ERROR("Attempt to read missing_value as one real element from multi-element netcdf attribute: "
			    + varname);
	}
#ifdef REAL_IS_FLOAT
	NC_CHECK(nc_get_att_float(ncid_, varid, missing_value, &missing_val), varname);
	return true;
#else
	NC_CHECK(nc_get_att_double(ncid_, varid, missing_value, &missing_val), varname);
	return true;
#endif
	
      }
      missing_value = "_FillValue";
    }
  }
  return false;
}
